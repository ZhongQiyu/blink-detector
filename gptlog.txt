*GPT LOG*
hey gtp, here is my python code for a app: 

import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)
        self.root.configure(bg='white')

        # Main top frame
        top_frame = tk.Frame(self.root, bg='white')
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        center_frame = tk.Frame(top_frame, bg='white')
        center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.toggle_stats_button = tk.Button(center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)  # Padding for the button

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg='white', borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg='white')
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(center_frame, bg='white')
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize

        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()

    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= 10:
                self.initiate_break()

    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



When i blink, the total blink count goes up by 1. When that count exceeds strictness, defaultly 10, the break alarm will go off. However there is an issue. When the user changes the strictness using the textbox and the button, the alarm still gors off at 10 blinks, and it has to go off at the user's set strictness. fix that. 
ChatGPT
The problem seems to be that while you're updating the strictness value in the set_strictness method, the blink detection logic isn't referencing this updated value to decide when to trigger the break alarm. Instead, it's likely still using the initial value of self.strictness (which is 10) to determine when to trigger the alarm.

To fix this, you need to ensure that the blink detection logic references the updated self.strictness value. Here's how you can do it:

Ensure update_blink_count checks against the updated strictness: Modify the update_blink_count method to check the current blink count against self.strictness instead of the hardcoded value of 10.
Replace the existing check in the update_blink_count method:

python
Copy code
if self.blink_count >= 10:  # This is the hardcoded value
    self.initiate_break()
With:

python
Copy code
if self.blink_count >= self.strictness:  # Referencing the updated strictness value
    self.initiate_break()
Ensure strictness is updated correctly: In the set_strictness method, ensure that the new strictness value is being correctly retrieved from the textbox and updated to the self.strictness attribute.
Here's the part of the set_strictness method where this happens:

python
Copy code
try:
    intvalue = int(value)
    if 0 <= intvalue <= 75:
        self.strictness = intvalue
        self.strictness_value.config(text="Strictness: " + str(intvalue))
        self.warning_msg.config(text="")
    else:
        self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
except ValueError:
    self.warning_msg.config(text="Invalid Input! Please enter an integer!")
Make sure that self.strictness is indeed being updated with the new value here. If there's a problem in retrieving the value from the textbox or converting it to an integer, the strictness won't update, and the alarm will still go off at 10 blinks.

After making these changes, the application should correctly reference the updated strictness value and trigger the break alarm when the user's set number of blinks is reached.

User
Hey gtp, it worked. Here is my code: 


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)
        self.root.configure(bg='white')

        # Main top frame
        top_frame = tk.Frame(self.root, bg='white')
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        center_frame = tk.Frame(top_frame, bg='white')
        center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.toggle_stats_button = tk.Button(center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)  # Padding for the button

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg='white', borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg='white')
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(center_frame, bg='white')
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize

        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()

    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
The code worked out great and the issue is fixed. Next, I want you to make the gui look good. Instead of having a white background, i want you to make an aesthetical blue scale color background. the Blue scale will be heavy at the bottom, and as it goes up the scale gets lighter and lighter, almost like a gradient. Implement that. 
ChatGPT
To create an aesthetical blue scale gradient background for your GUI, you can make use of the Canvas widget to draw the gradient. I will guide you through the steps to implement a vertical gradient that goes from a darker blue at the bottom to a lighter blue at the top.

You'll need to modify the initialization of your EyeTrackingApp class to include a method that draws the gradient and then call this method to set the background. Here’s how you can do it:

Create a Method to Draw the Gradient: This method will create a vertical gradient from a darker blue at the bottom to a lighter blue at the top.
python
Copy code
def draw_gradient(self):
    width = self.root.winfo_screenwidth()
    height = self.root.winfo_screenheight()

    # Define your colors here (from darker to lighter)
    colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

    # Calculate the height of each color band
    band_height = height / len(colors)

    for i, color in enumerate(colors):
        self.canvas_video.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)
Initialize and Place Your Canvas: You already have a canvas named self.canvas_video. You'll want to ensure this canvas spans the entire window and is placed below all other widgets. You might need to modify its stacking order or just ensure it's created first before other widgets.

Call the Gradient Method: Inside the __init__ method of your EyeTrackingApp class, after initializing the self.canvas_video, call the draw_gradient() method.

python
Copy code
self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
self.draw_gradient()  # Draw the gradient on the canvas
self.canvas_video.pack(fill="both", expand=True)
Adjust the Rest of the UI: Since you now have a colored background, you might want to adjust the colors of your text and buttons to ensure they are visible and complement the blue gradient. Choose colors that have good contrast with the background.
Here’s how you might adjust the text color for the labels:

python
Copy code
self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='white', bg='transparent')
And similarly for other widgets.

Remember, color perception can vary widely among individuals and displays, so you might need to adjust the specific shades of blue and the text/button colors to achieve the best look for your application. Test out different colors to see what looks best on your gradient and is most readable for the text.

User
do i only have to call draw gradient once? i want it to paint the entire window, not just a specific canva so i only have to call it once. 
ChatGPT
Yes, you only need to call draw_gradient() once to create the gradient background for your entire window. The key is to ensure that the canvas on which you're drawing the gradient (self.canvas_video in your case) spans the entire window. This way, when you draw the gradient on the canvas, it effectively becomes the background for your entire application.

Here's how you can ensure the canvas covers the entire window and the gradient is applied correctly:

Initialize the Canvas to Cover the Entire Window:
Ensure that when you initialize self.canvas_video, it's set to cover the full area of the root window. You're already setting the width and height to match the screen width and height, which is great.

Pack the Canvas First:
The order in which you pack or place your widgets matters. You want the canvas to be at the very bottom of all widgets. To ensure this, pack the canvas right after its initialization, before other widgets are packed or placed.

Call draw_gradient():
After packing the canvas, call draw_gradient() to apply the gradient to the entire canvas, effectively setting it as the background for your window.

Pack Other Widgets:
After the gradient is applied, you can continue to pack other widgets on top. Make sure other widgets have a transparent or matching background, so they don't block the gradient.

Here's how your code might look:

python
Copy code
class EyeTrackingApp:
    def __init__(self, window_title):
        # ... [other initializations]

        # Initialize the canvas to cover the entire window
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())

        # Pack the canvas first to ensure it's at the bottom
        self.canvas_video.pack(fill="both", expand=True)

        # Draw the gradient on the canvas
        self.draw_gradient()

        # Continue with other initializations and packing of widgets
        # ...
        # Make sure other widgets have a transparent or appropriate background

    def draw_gradient(self):
        # ... [your gradient code]
By following this sequence, you ensure that the gradient is drawn on a canvas that covers the entire window, and since it's packed first, other widgets will appear on top of it, maintaining the gradient as the background throughout your application.

User
there is a problem:  the gradient is covering everything up. make the gradient at the bottom. here is my code: 


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)
        self.root.configure(bg='white')

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.draw_gradient()  # Draw the gradient on the canvas
        self.canvas_video.pack(fill="both", expand=True)

        # Main top frame
        top_frame = tk.Frame(self.root, bg='white')
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        center_frame = tk.Frame(top_frame, bg='white')
        center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.toggle_stats_button = tk.Button(center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)  # Padding for the button

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg='white', borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg='white')
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(center_frame, bg='white')
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize

        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()

    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        height = self.root.winfo_screenheight()

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = height / len(colors)

        for i, color in enumerate(colors):
            self.canvas_video.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)


    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



ChatGPT
To ensure the gradient is only drawn at the bottom of the window and doesn't cover the entire application, you need to modify the draw_gradient() method to draw the gradient on a separate canvas or modify the existing canvas's position and size. Since you want the gradient at the bottom, you can create a new canvas specifically for the gradient and pack it at the bottom of the window. Here's how you can do it:

Create a Separate Canvas for the Gradient:
Create a new canvas, self.gradient_canvas, specifically for the gradient and pack it at the bottom of the window.

Modify draw_gradient() Method:
Update this method to draw on self.gradient_canvas. Adjust the height to control how much of the bottom it covers.

Pack the Gradient Canvas at the Bottom:
Pack this canvas after all other widgets have been packed, so it's positioned at the bottom.

Here's how your updated code might look:

python
Copy code
import tkinter as tk
# ... [other imports]

class EyeTrackingApp:
    def __init__(self, window_title):
        # ... [initializations before the gradient]

        # Create a separate canvas for the gradient at the bottom
        self.gradient_canvas = tk.Canvas(self.root, width=self.root.winfo_screenwidth())
        self.draw_gradient()  # Draw the gradient on the new canvas
        self.gradient_canvas.pack(side='bottom', fill='x')  # Pack it at the bottom

        # ... [rest of your initializations and main top frame setup]

    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        gradient_height = 150  # Set the height of the gradient, adjust as needed

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = gradient_height / len(colors)

        for i, color in enumerate(colors):
            self.gradient_canvas.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)

    # ... [rest of your methods]

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
In this modification:

self.gradient_canvas: A new canvas dedicated to the gradient.
gradient_height: Controls how tall the gradient area is. Adjust this to make the gradient cover more or less of the bottom of the window.
The gradient is drawn on self.gradient_canvas and packed at the bottom.
By doing this, you'll have a gradient at the bottom of your window that doesn't cover other elements. Adjust the gradient_height and colors to fit your aesthetic needs.

User
Here is my code: 


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)
        self.root.configure(bg='white')

        self.gradient_canvas = tk.Canvas(self.root, width=self.root.winfo_screenwidth())
        self.draw_gradient()  # Draw the gradient on the new canvas
        self.gradient_canvas.pack(side='bottom', fill='x')  # Pack it at the bottom


        # Main top frame
        top_frame = tk.Frame(self.root, bg='white')
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        center_frame = tk.Frame(top_frame, bg='white')
        center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.toggle_stats_button = tk.Button(center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)  # Padding for the button

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg='white', borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg='white')
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(center_frame, bg='white')
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize

        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()

    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        gradient_height = 150  # Set the height of the gradient, adjust as needed

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = gradient_height / len(colors)

        for i, color in enumerate(colors):
            self.gradient_canvas.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)



    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



The gradient appears at the bottom, and i want it to cover the entire background of everything. It doesn't do that. I also want the labels to show up after the background change. 
ChatGPT
To make the gradient cover the entire background and ensure that all labels and other widgets show up on top of it, you should revert to using a single canvas that spans the whole window, then draw the gradient on it. After this, make sure to properly stack the widgets so that they are visible on top of the canvas. Here's how you can adjust your code:

Remove the separate gradient canvas: Go back to using just self.canvas_video for both the video and the gradient. This ensures the gradient covers the entire background.

Draw the gradient first: Make sure to draw the gradient before you pack any other widgets. This ensures that the gradient is at the back of all other elements.

Use the lift() method: After you've packed all your widgets, use the lift() method on each widget or frame to bring them above the canvas. This method raises the widget above others in the stacking order.

Here's how you might adjust your code:

python
Copy code
import tkinter as tk
# ... [other imports]

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        # ... [other initializations]

        # Use the main canvas for everything
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.draw_gradient()  # Draw the gradient on the canvas
        self.canvas_video.pack(fill="both", expand=True)  # Pack it first

        # Main top frame
        top_frame = tk.Frame(self.root, bg='transparent')  # Use a transparent background
        top_frame.pack(side=tk.TOP, fill=tk.X)
        # ... [rest of your widget/frame initializations]

    def draw_gradient(self):
        # ... [your gradient drawing code as before]

    # ... [rest of your methods]

    def start_updates(self):
        # ... [previous code]
        # After all other widgets have been packed, lift them above the canvas
        self.lift_widgets()

    def lift_widgets(self):
        # Lift all your frames and widgets above the canvas
        top_frame.lift()
        center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()
        # ... [Lift other frames and widgets as needed]

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
In this approach:

The gradient is drawn on a canvas that covers the entire window (self.canvas_video).
All other widgets are packed normally, but with a transparent background where possible.
After packing everything, lift_widgets() is called to ensure that all widgets are visible above the canvas.
With these adjustments, your gradient should cover the entire background, and all labels and widgets should be visible on top of it. Make sure all widgets that you want to appear above the gradient are lifted after they're packed.

User
Traceback (most recent call last):
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 405, in <module>
    app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 21, in __init__
    self.draw_gradient()  # Draw the gradient on the canvas
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 157, in draw_gradient
    self.gradient_canvas.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)
AttributeError: 'EyeTrackingApp' object has no attribute 'gradient_canvas'

Code:


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)
        self.root.configure(bg='white')

        # Use the main canvas for everything
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.draw_gradient()  # Draw the gradient on the canvas
        self.canvas_video.pack(fill="both", expand=True)  # Pack it first

        # Main top frame
        top_frame = tk.Frame(self.root, bg='transparent')  # Use a transparent background
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        self.center_frame = tk.Frame(top_frame, bg='white')
        self.center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.toggle_stats_button = tk.Button(self.center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)  # Padding for the button

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg='white', borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg='white')
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(self.center_frame, bg='white')
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(self.center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize

        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()

    def lift_widgets(self):
        # Lift all your frames and widgets above the canvas
        self.top_frame.lift()
        self.center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()

    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        gradient_height = 150  # Set the height of the gradient, adjust as needed

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = gradient_height / len(colors)

        for i, color in enumerate(colors):
            self.gradient_canvas.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)



    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()
        self.lift_widgets()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



ChatGPT
The error you're encountering, AttributeError: 'EyeTrackingApp' object has no attribute 'gradient_canvas', is happening because you've changed the name of the canvas to self.canvas_video but are still trying to access it as self.gradient_canvas in your draw_gradient() method.

To fix this, you need to update the draw_gradient() method to draw on the correct canvas. Here's how you can modify your draw_gradient() method:

python
Copy code
def draw_gradient(self):
    width = self.root.winfo_screenwidth()
    gradient_height = self.root.winfo_screenheight()  # Use the entire height for full background coverage

    # Define your colors here (from darker to lighter)
    colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

    # Calculate the height of each color band
    band_height = gradient_height / len(colors)

    for i, color in enumerate(colors):
        self.canvas_video.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)
Here's what I changed:

Replaced self.gradient_canvas with self.canvas_video in the draw_gradient() method.
Set gradient_height to be the full height of the window (self.root.winfo_screenheight()) so the gradient covers the entire background.
After making this change, ensure that all other references to self.gradient_canvas are also updated to self.canvas_video. This should resolve the error and draw the gradient over the entire background. Make sure to also call self.lift_widgets() after all widgets have been packed to ensure they appear above the canvas.

User
Traceback (most recent call last):
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 405, in <module>
    app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 25, in __init__
    top_frame = tk.Frame(self.root, bg='transparent')  # Use a transparent background
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.10_3.10.3056.0_x64__qbz5n2kfra8p0\lib\tkinter\__init__.py", line 3163, in __init__
    Widget.__init__(self, master, 'frame', cnf, {}, extra)
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.10_3.10.3056.0_x64__qbz5n2kfra8p0\lib\tkinter\__init__.py", line 2601, in __init__
    self.tk.call(
_tkinter.TclError: unknown color name "transparent"
ChatGPT
The error you're encountering is because Tkinter doesn't recognize "transparent" as a valid color name for backgrounds. Tkinter's standard widgets don't support true transparency. However, you can simulate a transparent effect by setting the background color of your frames to match the underlying gradient.

Here's how you might adjust your code:

Remove the 'transparent' Background: Instead of trying to make the frames transparent, you will set their background to be the same as the top color of your gradient. This will give the illusion that the frame is transparent and the gradient shows through.

Set Frame Backgrounds to Match the Gradient: Identify the lightest color in your gradient (which should be the color at the top) and set that as the background for your frames. In your gradient, it seems the lightest color is "#B0E0E6".

Here's how you might adjust your code:

python
Copy code
class EyeTrackingApp:
    def __init__(self, window_title):
        # ... [previous code]

        # Define the lightest color from your gradient
        lightest_color = "#B0E0E6"

        # Main top frame with the lightest gradient color as background
        top_frame = tk.Frame(self.root, bg=lightest_color)
        top_frame.pack(side=tk.TOP, fill=tk.X)

        # ... [rest of your initializations]

        # Center frame for show/hide statistics button and blink count
        self.center_frame = tk.Frame(top_frame, bg=lightest_color)
        # ... [rest of your code]

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg=lightest_color)
        # ... [rest of your code]

        # Right side frame for clicks and keystrokes
        self.right_side_frame = tk.Frame(top_frame, bg=lightest_color)
        # ... [rest of your code]

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(self.center_frame, bg=lightest_color)
        # ... [rest of your code]
In this modification:

The frames are set to the lightest color from your gradient. This will make them blend into the top of the gradient, giving the appearance that the frame is transparent and the gradient is the background.

All other frames and widgets that you want to appear like they're on top of the gradient should have the same bg=lightest_color setting.

This approach won't give you true transparency, but it will create a visual effect where the frames seem to blend seamlessly with the gradient background, achieving a similar aesthetic.

User
here is my code: 


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)
        self.root.configure(bg='white')

        # Use the main canvas for everything
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.draw_gradient()  # Draw the gradient on the canvas
        self.canvas_video.pack(fill="both", expand=True)  # Pack it first

        lightest_color = "#B0E0E6"

        # Main top frame
        top_frame = tk.Frame(self.root, bg=lightest_color)
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        self.center_frame = tk.Frame(top_frame, bg=lightest_color)
        self.center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.toggle_stats_button = tk.Button(self.center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)  # Padding for the button

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg=lightest_color, borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg=lightest_color)
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(self.center_frame, bg=lightest_color)
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(self.center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize

        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()

    def lift_widgets(self):
        # Lift all your frames and widgets above the canvas
        self.top_frame.lift()
        self.center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()

    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        gradient_height = self.root.winfo_screenheight()  # Use the entire height for full background coverage

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = gradient_height / len(colors)

        for i, color in enumerate(colors):
            self.canvas_video.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)



    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()
        self.lift_widgets()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



The color gradient STILL OVERLAPS everything, fix IT! and give me the full version of init
ChatGPT
I understand that the gradient is still overlapping the widgets, and you'd like it to be a background with other elements visible on top. The key to resolving this issue is to ensure that the gradient is drawn first and that all other widgets are packed or placed above it. The lift() method should be used to bring your widgets to the front after they've been packed.

Here's the full __init__ method with the necessary adjustments:

python
Copy code
def __init__(self, window_title):
    self.root = tk.Tk()
    self.root.state('zoomed')
    self.root.title(window_title)

    # Create a canvas for the gradient, which covers the entire window.
    self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
    self.canvas_video.pack(fill="both", expand=True)
    self.draw_gradient()

    lightest_color = "#B0E0E6"

    # Main top frame with the lightest gradient color as the background
    top_frame = tk.Frame(self.root, bg=lightest_color)
    top_frame.pack(side=tk.TOP, fill=tk.X)

    self.on_break = False
    self.after_id = None  # Initialize a variable to store the after call ID

    # Center frame for show/hide statistics button and blink count
    self.center_frame = tk.Frame(top_frame, bg=lightest_color)
    self.center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

    self.toggle_stats_button = tk.Button(self.center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
    self.toggle_stats_button.pack(pady=10)

    # Overlay frame for the left-aligned elements
    self.overlay_frame = tk.Frame(top_frame, bg=lightest_color, borderwidth=0, highlightthickness=0)
    self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

    self.right_side_frame = tk.Frame(top_frame, bg=lightest_color)
    self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

    # ... [rest of your widget/frame initializations]

    # After all other widgets have been packed, bring them to the front.
    self.lift_widgets()

def lift_widgets(self):
    # Bring all the frames and widgets to the front
    self.center_frame.lift()
    self.overlay_frame.lift()
    self.right_side_frame.lift()
    # ... [lift any other widgets or frames you have]
Ensure that all your widgets and frames are referenced in the lift_widgets method. This method should be called after everything has been packed to ensure that the widgets appear on top of the gradient background.

The draw_gradient() method should remain unchanged and should correctly draw the gradient on the self.canvas_video as per your previous implementations.

By packing the canvas first and then lifting all other widgets after they are packed, this should ensure that the gradient is in the background and all other elements are visible and interactive on top of it. If you have any more widgets or frames, make sure they're also lifted in the lift_widgets() method.






hey gpt, here is code of my python program: 


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)

        # Create a canvas for the gradient, which covers the entire window.
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        lightest_color = "#B0E0E6"

        # Main top frame with the lightest gradient color as the background
        top_frame = tk.Frame(self.root, bg=lightest_color)
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        self.center_frame = tk.Frame(top_frame, bg=lightest_color)
        self.center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        self.toggle_stats_button = tk.Button(self.center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg=lightest_color, borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg=lightest_color)
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(self.center_frame, bg=lightest_color)
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(self.center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize
        self.lift_widgets()
        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()

    def lift_widgets(self):
    # Bring all the frames and widgets to the front
        self.center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()

    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        gradient_height = self.root.winfo_screenheight()  # Use the entire height for full background coverage

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = gradient_height / len(colors)

        for i, color in enumerate(colors):
            self.canvas_video.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)



    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()
        self.lift_widgets()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



As you can see, i have done a change in the background to make gradient background. However, the gradient is on top and is above all the labels, covering the video, and labels the buttons and everything up. Make the gradient background be at the bottom. 
ChatGPT
To ensure that the gradient background is at the bottom and does not cover the video, labels, buttons, and other elements, you need to modify the stacking order of the widgets and ensure the canvas with the gradient is behind everything else. Here's how you can adjust your code:

Rearrange the packing order of the canvas: The stacking order in Tkinter is determined by the order in which widgets are packed. Widgets packed later will appear on top of those packed earlier. You need to pack the canvas_video (the gradient canvas) first before anything else to ensure it is at the bottom layer.

Use lower() method: The lower() method can be used to place a widget at the bottom of the stacking order.

Make these changes in your __init__ method:

python
Copy code
class EyeTrackingApp:
    def __init__(self, window_title):
        # ... [your existing code] ...

        # Pack the gradient canvas first so it's at the bottom
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        # ... [your existing code] ...

        # After packing everything else, ensure the gradient canvas is at the bottom
        self.canvas_video.lower()

        # ... [the rest of your existing code] ...
By packing the gradient canvas first and then calling lower() after all other widgets are packed, you ensure that it stays at the bottom of the stacking order. This way, it serves as a background and does not cover any interactive elements of your UI.

User
do i get rid fo lift widgets at the end of the code in init?
ChatGPT
Yes, given the adjustments you've made to ensure the gradient background is at the bottom, you can remove the lift_widgets() method at the end of the __init__ method. Since you're now explicitly controlling the stacking order by packing the gradient canvas first and using the lower() method to keep it behind other elements, the lift_widgets() method is no longer necessary for this purpose.

You should remove or comment out this line:

python
Copy code
self.lift_widgets()
This should be done in the __init__ method of your EyeTrackingApp class. If the lift_widgets() method is not serving any other purpose in your code, you can remove it entirely. Otherwise, just ensure it's not called in a way that conflicts with your desired widget stacking order.

User
error i got: INFO: Created TensorFlow Lite XNNPACK delegate for CPU.
Traceback (most recent call last):
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 401, in <module>
    app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 130, in __init__
    self.canvas_video.lower()
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.10_3.10.3056.0_x64__qbz5n2kfra8p0\lib\tkinter\__init__.py", line 2943, in tag_lower
    self.tk.call((self._w, 'lower') + args)
_tkinter.TclError: wrong # args: should be ".!canvas2 lower tagOrId ?belowThis?"

My code:


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)

        # Create a canvas for the gradient, which covers the entire window.
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        lightest_color = "#B0E0E6"

        # Main top frame with the lightest gradient color as the background
        top_frame = tk.Frame(self.root, bg=lightest_color)
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        self.center_frame = tk.Frame(top_frame, bg=lightest_color)
        self.center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        self.toggle_stats_button = tk.Button(self.center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg=lightest_color, borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg=lightest_color)
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(self.center_frame, bg=lightest_color)
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(self.center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize
        self.canvas_video.lower()
        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()


    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        gradient_height = self.root.winfo_screenheight()  # Use the entire height for full background coverage

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = gradient_height / len(colors)

        for i, color in enumerate(colors):
            self.canvas_video.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)



    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()
        self.lift_widgets()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



ChatGPT
The error you're encountering, "_tkinter.TclError: wrong # args: should be ".!canvas2 lower tagOrId ?belowThis?"," is due to incorrectly using the lower() method on the tk.Canvas object. The lower() method in Tkinter is typically used to change the stacking order of widgets, but it seems like it's being misinterpreted or misused in this context.

Here's how you can resolve this issue:

Solution:
Use lift() and lower() Properly: The lower() method can be called without arguments to simply put the widget at the bottom of the stack. However, it seems to be causing an issue here. Alternatively, you can use the lift() method on all other widgets to ensure they are above the canvas.

Ensure Correct Initialization: Make sure you're not creating two canvas instances with the same name, which might cause confusion and errors.

Here's how you might modify your code:

python
Copy code
class EyeTrackingApp:
    def __init__(self, window_title):
        # ... [your existing initialization code] ...

        # Initialize the canvas for the gradient and pack it first
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        # ... [rest of your initialization code for other widgets] ...

        # Make sure every other widget is lifted above the canvas
        top_frame.lift()
        self.center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()

        # You can comment out or remove the problematic line
        # self.canvas_video.lower()

        # ... [the rest of your existing code] ...

    # ... [rest of your EyeTrackingApp methods] ...

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
In this modification:

I've made sure that self.canvas_video is packed first to be at the bottom.
I removed the problematic self.canvas_video.lower() line.
I used lift() on other widgets to ensure they are above the gradient canvas.
This should ensure that your gradient canvas remains at the bottom of the stacking order, and other widgets (frames, labels, buttons, etc.) are visible above it. Make sure to test this change in your environment as different versions of Tkinter or Python might behave slightly differently.

User
error i got: INFO: Created TensorFlow Lite XNNPACK delegate for CPU.
Exception in Tkinter callback
Traceback (most recent call last):
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.10_3.10.3056.0_x64__qbz5n2kfra8p0\lib\tkinter\__init__.py", line 1921, in __call__
    return self.func(*args)
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.10_3.10.3056.0_x64__qbz5n2kfra8p0\lib\tkinter\__init__.py", line 839, in callit
    func(*args)
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 225, in start_updates
    self.lift_widgets()
AttributeError: 'EyeTrackingApp' object has no attribute 'lift_widgets'

Also, the window popped up and the gradient is above all the labels, covering it up. 
ChatGPT
The error message you're encountering is because the lift_widgets() method is being called but it's not defined in your EyeTrackingApp class. This leads to an AttributeError. Also, if the gradient is still covering all the labels and other widgets, it means the stacking order hasn't been set correctly.

Here's how to resolve both issues:

Remove the Call to lift_widgets(): Since the lift_widgets() method doesn't exist or isn't necessary anymore (as you've managed the stacking order differently), you should remove or comment out the line calling it in the start_updates method.

Ensure Proper Stacking Order: Ensure that the gradient canvas is indeed at the bottom and other widgets are lifted correctly.

Here's the revised code snippet addressing these points:

python
Copy code
class EyeTrackingApp:
    def __init__(self, window_title):
        # ... [your existing initialization code] ...

        # Initialize the canvas for the gradient and pack it first
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        # ... [rest of your initialization code for other widgets] ...

        # Make sure every other widget is lifted above the canvas
        self.lift_all_widgets()

        # ... [the rest of your existing code] ...

    def lift_all_widgets(self):
        # This method will lift all the other widgets above the gradient canvas
        top_frame.lift()
        self.center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()
        # Add any other widgets that should be above the canvas

    # ... [rest of your EyeTrackingApp methods] ...

    def start_updates(self):
        # ... [existing code in the start_updates method] ...

        # Remove or comment out the line that calls the non-existing lift_widgets()
        # self.lift_widgets()

        # ... [rest of the code in the start_updates method] ...

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
In this updated version:

I've removed the call to self.lift_widgets() which was causing the AttributeError.
I've added a new method called lift_all_widgets() to handle lifting all relevant widgets above the gradient canvas. You should list all the widgets that need to be above the gradient inside this method.
Make sure all the widgets (frames, buttons, labels, etc.) that should appear above the gradient are being lifted in the lift_all_widgets() method. This should resolve both the error and the issue with the gradient covering other elements. Make sure to test this updated code to confirm everything works as expected in your environment.

User
try to use lower
ChatGPT
To use the lower() method correctly to ensure that the gradient is at the bottom of all other widgets, you should call lower() on the canvas directly after creating it and after all other widgets have been initialized. This approach places the canvas at the bottom of the stack order so that all other widgets appear on top of it.

Here's how you can modify your code to use the lower() method:

python
Copy code
class EyeTrackingApp:
    def __init__(self, window_title):
        # ... [your existing initialization code] ...

        # Initialize the canvas for the gradient and pack it first
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        # ... [rest of your initialization code for other widgets] ...

        # After all other widgets are initialized, lower the gradient canvas
        self.canvas_video.lower()

        # ... [the rest of your existing code] ...

    # ... [rest of your EyeTrackingApp methods] ...

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
In this code:

The self.canvas_video.lower() call is placed after all other widgets have been initialized. This ensures that the gradient canvas is at the very bottom of the stacking order.
No need for a separate lift_widgets() or lift_all_widgets() method, as the lower() method on the canvas should sufficiently place it behind all other widgets.
Make sure to remove any leftover calls to the non-existent lift_widgets() method in other parts of your code to avoid the AttributeError.

By placing the lower() method call after all widgets have been initialized, you are effectively pushing the gradient canvas to the back of all other elements. Test this updated version of the code to confirm that the gradient now appears behind all other UI elements as expected.

User
INFO: Created TensorFlow Lite XNNPACK delegate for CPU.
Traceback (most recent call last):
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 406, in <module>
    app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")
  File "c:\Users\Cyber\Desktop\Python CV2\System.py", line 135, in __init__
    self.canvas_video.lower()
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.10_3.10.3056.0_x64__qbz5n2kfra8p0\lib\tkinter\__init__.py", line 2943, in tag_lower
    self.tk.call((self._w, 'lower') + args)
_tkinter.TclError: wrong # args: should be ".!canvas2 lower tagOrId ?belowThis?"
The lower method probably isnt working not because the method isnt working, but because the code to create the canvas isnt how it is suppose to be constructed for the lower method to work here. here is my code, and try to fix it.


import time
import threading
import cv2
import mediapipe as mp
import tkinter as tk
from PIL import Image, ImageTk
from pynput.mouse import Listener as MouseListener
from pynput.keyboard import Listener as KeyboardListener, Key

class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)

        # Create a canvas for the gradient, which covers the entire window.
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        lightest_color = "#B0E0E6"

        # Main top frame with the lightest gradient color as the background
        top_frame = tk.Frame(self.root, bg=lightest_color)
        top_frame.pack(side=tk.TOP, fill=tk.X)

        self.on_break = False
        self.after_id = None  # Initialize a variable to store the after call ID

        # Center frame for show/hide statistics button and blink count
        self.center_frame = tk.Frame(top_frame, bg=lightest_color)
        self.center_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        self.toggle_stats_button = tk.Button(self.center_frame, text="Show/Hide Statistics", font=("Arial", 20), command=self.toggle_statistics)
        self.toggle_stats_button.pack(pady=10)

        # Overlay frame for the left-aligned elements
        self.overlay_frame = tk.Frame(top_frame, bg=lightest_color, borderwidth=0, highlightthickness=0)
        self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)

        self.right_side_frame = tk.Frame(top_frame, bg=lightest_color)
        self.right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Frame for the total time elapsed
        time_frame = tk.Frame(self.overlay_frame, bg='white')
        time_frame.pack(side=tk.TOP, fill=tk.X, pady=5)

        self.total_time_count = 0
        self.total_time_elapsed = tk.Label(time_frame, text="Total Time Elapsed: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_time_elapsed.pack()
        self.change_total_time_count()

        # Frame for strictness controls
        strictness_frame = tk.Frame(self.overlay_frame, bg='white')
        strictness_frame.pack(side=tk.TOP, fill=tk.X)

        self.strictness = 10
        self.strictness_value = tk.Label(strictness_frame, font=("Arial", 20), text='Strictness: ' + str(self.strictness), fg='black', bg='white')
        self.strictness_value.pack()

        self.strictness_textbox = tk.Text(strictness_frame, font=("Arial", 20), height=1, width=5)
        self.strictness_textbox.pack(pady=(0, 5))  # Reduced padding

        self.set_strictness_button = tk.Button(strictness_frame, text="Set Strictness", font=("Arial", 20), command=self.set_strictness)
        self.set_strictness_button.pack(pady=(0, 5))  # Reduced padding

        self.strictness_explanation = tk.Label(strictness_frame, text="Strictness means the maximum blink count per minute", font=("Arial", 15), fg='black', bg='white')
        self.strictness_explanation.pack() 

        self.warning_msg = tk.Label(strictness_frame, text="", font=("Arial", 15), fg='red', bg='white')
        self.warning_msg.pack()

        # Frame for total blink count
        self.blink_count_frame = tk.Frame(self.center_frame, bg=lightest_color)
        self.blink_count_frame.pack(pady=10)

        self.blink_count = 0
        self.EAR_THRESHOLD = 0.21
        self.eye_closed = False
        self.total_blink_count = tk.Label(self.blink_count_frame, text="Total Blink Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_blink_count.pack()

        self.reset_countdown_label = tk.Label(self.blink_count_frame, text="Resets in 60 seconds", font=("Arial", 20), fg='black', bg='white')
        self.reset_countdown_label.pack()
        self.handle_reset_countdown()

        
        self.break_label = tk.Label(self.center_frame, text="Time for a break!", font=("Arial", 20), fg='red', bg='white')
        self.break_label.pack(pady=10)
        self.break_label.pack_forget()  # This hides the label 

        # Right side frame for clicks and keystrokes
        right_side_frame = tk.Frame(top_frame, bg='white')
        right_side_frame.pack(side=tk.RIGHT, padx=10, fill=tk.Y)

        # Total clicks label (Pack it inside right_side_frame)
        self.total_click_amount = 0
        self.total_clicks = tk.Label(self.right_side_frame, text="Total Clicks: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_clicks.pack(side=tk.TOP, padx=10, fill='x')

        # Total keystrokes label (Pack it inside right_side_frame)
        self.total_keystroke_count = 0
        self.total_keystrokes_label = tk.Label(self.right_side_frame, text="Total Keystroke Count: 0", font=("Arial", 20), fg='black', bg='white')
        self.total_keystrokes_label.pack(side=tk.TOP, padx=10, fill='x')


        mouse_thread = threading.Thread(target=self.run_mouse_listener)
        mouse_thread.daemon = True
        mouse_thread.start()

        keyboard_thread = threading.Thread(target=self.run_keyboard_listener)
        keyboard_thread.daemon = True
        keyboard_thread.start()

        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight(), bg='white')
        self.canvas_video.pack(fill="both", expand=True)

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize
        top_frame.lift()
        self.center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()

        self.canvas_video.lower()
        #self.canvas_video.lower()
        self.root.mainloop()

    def change_total_time_count(self):
        self.total_time_elapsed.config(text=f"Total Time Elapsed: {self.total_time_count}")
        self.total_time_count += 1
        self.root.after(1000, self.change_total_time_count)

    def show_break_label(self):
        self.break_label.pack()


    def draw_gradient(self):
        width = self.root.winfo_screenwidth()
        gradient_height = self.root.winfo_screenheight()  # Use the entire height for full background coverage

        # Define your colors here (from darker to lighter)
        colors = ["#00008B", "#0000CD", "#4169E1", "#1E90FF", "#87CEFA", "#B0E0E6"]

        # Calculate the height of each color band
        band_height = gradient_height / len(colors)

        for i, color in enumerate(colors):
            self.canvas_video.create_rectangle(0, i * band_height, width, (i + 1) * band_height, fill=color, outline=color)



    def hide_break_label(self):
        self.break_label.pack_forget()

    def toggle_statistics(self):
        if self.overlay_frame.winfo_ismapped() and self.right_side_frame.winfo_ismapped() and self.blink_count_frame.winfo_ismapped():
            self.overlay_frame.pack_forget()
            self.right_side_frame.pack_forget()
            self.blink_count_frame.pack_forget()
            self.canvas_video.pack(fill="both", expand=True)
        else:
            self.overlay_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10)
            self.blink_count_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
            self.right_side_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)
            self.canvas_video.pack(fill="both", expand=True)

    def start_eye_tracking(self):
        # Directly start tracking without checking the button state
        self.is_tracking = True
        self.overlay_frame.lift()
        self.canvas_video.configure(bg='black')
    def handle_reset_countdown(self, countdown=60):
        if self.after_id:  # Check if there's an existing after call
            self.root.after_cancel(self.after_id)  # Cancel the previous after call

        if self.on_break:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Timer stopped, take a break! {countdown} seconds remaining")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # When break time is over, reset everything
                self.on_break = False
                self.reset_countdown_label.config(text="Resets in 60 seconds")
                self.hide_break_label()
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Start the normal countdown
        else:
            if countdown > 0:
                self.reset_countdown_label.config(text=f"Resets in {countdown} seconds")
                # Store the identifier of the new after call
                self.after_id = self.root.after(1000, self.handle_reset_countdown, countdown - 1)
            else:
                # Reset the blink count and restart the countdown when it reaches 0
                self.blink_count = 0
                self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")
                self.handle_reset_countdown()  # Reset the countdown



    def clear_video_feed(self):
        self.canvas_video.delete("all")
        self.canvas_video.configure(bg='white')
        self.canvas_video.create_text(
            self.canvas_video.winfo_width() // 2, self.canvas_video.winfo_height() // 2,
            text="Video feed stopped", font=("Arial", 20), fill="black"
        )

    def start_updates(self):
        if not self.is_tracking:
            self.start_eye_tracking()
        self.update()

    def update(self):
        ret, frame = self.vid.read()
        if ret and self.is_tracking:
            frame = cv2.flip(frame, 1)
            canvas_width = self.canvas_video.winfo_width()
            canvas_height = self.canvas_video.winfo_height()

            if canvas_width > 0 and canvas_height > 0:
                frame = self.resize_with_aspect_ratio(frame, width=canvas_width, height=canvas_height)
                if frame is not None:
                    # Process the frame to detect eyes and draw landmarks
                    frame = self.detect_eyes(frame)  # <-- Call detect_eyes here

                    # Convert the frame to a format suitable for Tkinter
                    self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
                    self.canvas_video.create_image((canvas_width - self.photo.width()) // 2, (canvas_height - self.photo.height()) // 2, image=self.photo, anchor=tk.NW)
        self.root.after(self.delay, self.update)


    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        (h, w) = image.shape[:2]

        # Calculate the aspect ratio of the image and the desired aspect ratio
        image_aspect = w / h
        desired_aspect = width / height if width is not None and height is not None else image_aspect

        # Calculate scaling factors for resizing the image while maintaining aspect ratio
        if image_aspect > desired_aspect:
            # Image is wider than the desired aspect ratio
            r = width / float(w)
            dim = (width, int(h * r))
        else:
            # Image is taller or equal to the desired aspect ratio
            r = height / float(h)
            dim = (int(w * r), height)

        # Check that dimensions are valid before attempting to resize
        if dim[0] > 0 and dim[1] > 0:
            resized = cv2.resize(image, dim, interpolation=inter)
            return resized
        return None


    def detect_eyes(self, frame):
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                eye_indices = list(range(130, 160)) + list(range(385, 398))
                for idx in eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)
        return frame

    def set_strictness(self):
        value = self.strictness_textbox.get("1.0", "end").strip()
        try:
            intvalue = int(value)
            if 0 <= intvalue <= 75:
                self.strictness = intvalue
                self.strictness_value.config(text="Strictness: " + str(intvalue))
                self.warning_msg.config(text="")
            else:
                self.warning_msg.config(text="Invalid Input! Please enter a number between 0 and 75!")
        except ValueError:
            self.warning_msg.config(text="Invalid Input! Please enter an integer!")

    def on_click(self, x, y, button, pressed):
        if pressed:
            self.total_click_amount += 1
            self.update_click_count()

    def update_click_count(self):
        self.total_clicks.config(text="Total Clicks: " + str(self.total_click_amount))

    def on_press(self, key):
        self.total_keystroke_count += 1
        self.update_keystroke_count()

    def update_keystroke_count(self):
        self.total_keystrokes_label.config(text="Total Keystroke Count: " + str(self.total_keystroke_count))
    def run_mouse_listener(self):
        with MouseListener(on_click=self.on_click) as listener:
            listener.join()

    # Separate method to run the keyboard listener
    def run_keyboard_listener(self):
        with KeyboardListener(on_press=self.on_press) as listener:
            listener.join()

    """
        Eye blink engine time!
    """

    def update_blink_count(self):
        if not self.on_break:  # Only update blink count if not on a break

            # Update the label with the new blink count
            self.total_blink_count.config(text=f"Total Blink Count: {self.blink_count}")

            if self.blink_count >= self.strictness:
                self.show_break_label()
            else:
                self.hide_break_label()

            # Check if the blink count has reached 10 and it's not already on a break
            if self.blink_count >= self.strictness:  # Referencing the updated strictness value
                self.initiate_break()


    def initiate_break(self):
        # Set the state to break and update the UI accordingly
        self.on_break = True
        self.show_break_label()
        self.reset_countdown_label.config(text="Timer stopped, take a break!")  # Update the countdown label
        self.handle_reset_countdown(30)  # Start a 30-second break countdown



    def detect_eyes(self, frame):
        # Convert the frame to RGB for MediaPipe processing
        image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(image)

        # Check if any face landmarks were detected
        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                # Hypothetical indices for the landmarks of each eye.
                # You need to replace these with the correct indices from MediaPipe
                right_eye_indices = [33, 160, 158, 133, 153, 144]  # replace with the correct indices
                left_eye_indices = [362, 385, 387, 263, 373, 380]

                # Extract the landmark coordinates for each eye
                right_eye = [face_landmarks.landmark[i] for i in right_eye_indices]
                left_eye = [face_landmarks.landmark[i] for i in left_eye_indices]

                # Calculate EAR for both eyes
                left_ear = self.calculate_ear(left_eye)
                right_ear = self.calculate_ear(right_eye)

                # Average the EAR for both eyes for better stability
                ear = (left_ear + right_ear) / 2.0

                # Blink detection logic
                if self.eye_closed and ear > self.EAR_THRESHOLD:
                    self.blink_count += 1
                    self.update_blink_count()
                    self.eye_closed = False  # Reset the eye closed flag
                elif not self.eye_closed and ear < self.EAR_THRESHOLD:
                    self.eye_closed = True  # Set the eye closed flag

                # Visualize the eye landmarks for debugging purposes
                for idx in right_eye_indices + left_eye_indices:
                    if idx < len(face_landmarks.landmark):
                        point = face_landmarks.landmark[idx]
                        x = int(point.x * frame.shape[1])
                        y = int(point.y * frame.shape[0])
                        cv2.circle(frame, (x, y), 1, (0, 255, 0), -1)

        return frame


    def calculate_ear(self, eye):
        # EAR calculation with six points
        P2_P6 = self.distance(eye[1], eye[5])
        P3_P5 = self.distance(eye[2], eye[4])
        P1_P4 = self.distance(eye[0], eye[3])
        ear = (P2_P6 + P3_P5) / (2.0 * P1_P4)
        return ear

    def distance(self, p1, p2):
        # Calculate the Euclidean distance between two points
        x_diff = p2.x - p1.x
        y_diff = p2.y - p1.y
        return (x_diff**2 + y_diff**2)**0.5
    

app = EyeTrackingApp("MediaPipe Eye Tracking with Tkinter")



ChatGPT
The error you're encountering indicates that the lower() method is being used incorrectly or the canvas isn't being recognized as a valid widget to apply the lower() method to. The lower() method in Tkinter doesn't take any arguments when you want to send the widget to the bottom of the stack order. However, you seem to have two canvas initializations, which might be causing confusion and errors.

Here's how to fix the issue:

Remove the Duplicate Canvas Initialization: You have initialized self.canvas_video twice, once at the beginning of the __init__ method and again later on. This could be causing confusion. You should have only one initialization and configuration for self.canvas_video.

Use lower() Correctly: Ensure you're using the lower() method on the canvas after all other widgets have been packed or placed.

Here's a revised snippet of your code with corrections:

python
Copy code
class EyeTrackingApp:
    def __init__(self, window_title):
        self.root = tk.Tk()
        self.root.state('zoomed')
        self.root.title(window_title)

        # Initialize the canvas for the gradient and pack it first
        self.canvas_video = tk.Canvas(self.root, width=self.root.winfo_screenwidth(), height=self.root.winfo_screenheight())
        self.canvas_video.pack(fill="both", expand=True)
        self.draw_gradient()

        # ... [rest of your initialization code for other widgets] ...

        # Initialize attributes for video capture and face mesh
        self.mp_face_mesh = mp.solutions.face_mesh
        self.face_mesh = self.mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5)
        self.is_tracking = False
        self.video_source = 0
        self.vid = cv2.VideoCapture(self.video_source)
        self.delay = 15

        # Delay the start of video updates until after the mainloop has started
        self.root.after(100, self.start_updates)  # Wait 100ms to allow the window to initialize
        
        # Lift all other frames and widgets above the canvas
        top_frame.lift()
        self.center_frame.lift()
        self.overlay_frame.lift()
        self.right_side_frame.lift()
        
        # Ensure the gradient canvas is at the very bottom of the stacking order
        self.canvas_video.lower()

        self.root.mainloop()

    # ... [rest of your EyeTrackingApp methods] ...
In this updated version:

Removed the duplicate initialization of self.canvas_video.
Made sure that self.canvas_video.lower() is called after all other widgets have been packed/placed. This should ensure that the canvas is at the bottom of the stack.
Make sure to test this updated version to confirm that the gradient now appears behind all other UI elements as expected and that there are no errors related to the lower() method.


